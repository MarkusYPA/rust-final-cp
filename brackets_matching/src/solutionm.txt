use std::collections::HashMap;

/*
cargo run "++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>."
Hello World!

cargo run "+++++[>++++[>++++H>+++++i<<-]>>>++\n<<<<-]>>--------.>+++++.>."
Hi

cargo run "++++++++++[>++++++++++>++++++++++>++++++++++<<<-]>---.>--.>-.>++++++++++."
abc
*/

fn main() {
    let args: Vec<String> = std::env::args().collect();

    if args.len() == 2 {
        brain_fuck(&args[1]);
    }
}

fn brain_fuck(input: &str) {
    // move pointer: <, >
    // change byte: +, -
    // print byte: .
    // to loop end if byte is 0: [ 
    // to loop start if byte isn't 0: ] 

    let mut bytes: Vec<u8> = vec![0; 4096];
    let mut pointer: usize = 0;
    let mut char_i: usize = 0;

    // Input as vector se we can jump to different index
    let s: Vec<char> = input.chars().filter(|c| "<>+-.[]".contains(*c)).collect();

    // Map bracket pairs
    let bracket_map = bracket_pairs(&s);

    // What if index goes negative? Not tested.
    while char_i < s.len() {
        let c = s[char_i];

        match c {
            '>' => pointer += 1,
            '<' => pointer -= 1,
            '+' => bytes[pointer] += 1,
            '-' => bytes[pointer] -= 1,
            '.' => print!("{}", bytes[pointer] as char),
            '[' => {
                if bytes[pointer] == 0 {
                    char_i = *bracket_map.get(&char_i).unwrap();
                    continue;   // Don't increment char_i
                }
            }
            ']' => {
                if bytes[pointer] != 0 {
                    char_i = *bracket_map.get(&char_i).unwrap();
                    continue;
                }
            }
            _ => (),
        }

        char_i += 1;
    }
}

fn bracket_pairs(s: &Vec<char>) -> HashMap<usize, usize> {
    let mut map = HashMap::new();

    let mut opens = Vec::new();
    let mut closes = Vec::new();
    let mut founds = Vec::new();
    for (i, c) in s.iter().enumerate() {
        if *c == '[' {
            opens.push(i);
            founds.push('[');
        }

        if *c == ']' {
            if *founds.last().unwrap() == '[' {
                map.insert(i, *opens.last().unwrap());
                map.insert(*opens.last().unwrap(), i);

                opens.pop();
                founds.pop();
            } else {
                // This shouldn't happen. With good inputs the prev is always [
                closes.push(i);
                founds.push(']');
            }
        }
    }

    map
}

#[cfg(test)]
mod tests;
